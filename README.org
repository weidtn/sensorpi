* Introduction
A program to read different sensor's data connected to for example a raspberry pi and send it to an influxdb.

* Installation
It might be needed to install the dependencies for =opencv-python-headless=:
#+begin_src shell eval no
sudo apt install libaom0 libatlas3-base libavcodec58 libavformat58 libavutil56 libbluray2 libcairo2 libchromaprint1 libcodec2-0.8.1 libcroco3 libdatrie1 libdrm2 libfontconfig1 libgdk-pixbuf2.0-0 libgfortran5 libgme0 libgraphite2-3 libgsm1 libharfbuzz0b libjbig0 libmp3lame0 libmpg123-0 libogg0 libopenjp2-7 libopenmpt0 libopus0 libpango-1.0-0 libpangocairo-1.0-0 libpangoft2-1.0-0 libpixman-1-0 librsvg2-2 libshine3 libsnappy1v5 libsoxr0 libspeex1 libssh-gcrypt-4 libswresample3 libswscale5 libthai0 libtheora0 libtiff5 libtwolame0 libva-drm2 libva-x11-2 libva2 libvdpau1 libvorbis0a libvorbisenc2 libvorbisfile3 libvpx5 libwavpack1 libwebp6 libwebpmux3 libx264-155 libx265-165 libxcb-render0 libxcb-shm0 libxfixes3 libxrender1 libxvidcore4 libzvbi0
#+end_src

* Configuration
All configuration is done in the config.edn file.
If you add a sensor here, it will automatically be read by the program and added to the measurement.
InfluxDB data also has to be set up in here it defaults to a local installation on the same raspberry pi without any authentication. To use a remote InfluxDB, change the URL in the config file.

The configuration is written in edn. This works similar to a python dictionary. Keywords and values are separated by whitespace.
You have to provide the keywords =:influxdb= and =:sensors= with your data. An example config.edn would look like this:
#+begin_src clojure :eval no
;; This is just an example config.edn file, you have to manually change the data.
{:influxdb {:url "http://localhost:8086"
            :db "test1"}

 :sensors {:cam  ;; name of the sensor
           {:type "camera" ;; type of the sensor. check supported types
            :rotate true} ;; some further possible options depending on sensor
           :ds18b20_1
           {:type "ds18b20"}
           :dht11_inside
           {:type "dht11"
            :pin 26}
           "TSL2591 upside down" ;; the sensor names can also just be strings
           {:type "tsl2591"}

           :bme280
           {:type "bme280"
            :address 0x76
            :protocol "i2c"}
           :bmp280_0
           {:type "bmp280"
            :protocol "spi"
            :pin "18"}
           :bmp280_1
           {:type "bmp280"
            :protocol "spi"
            :pin "12"}}}
#+end_src
* Supported sensors
Currently the following sensors are supported. Their implementations can be found in the sensorpi/sensors folder.

- Camera (Integrating histogram)
- DHT11
- DS18B20
- TSL2591
- BMP280 (I2C, SPI)
- BME280 (I2C, SPI)

Multiple sensors should work if different addresses (I2C) or pins (SPI) are used.

** Camera
(type ="camera"=)
The camera can be used as a sensor. This currently only includes taking a photo and integrating its histogram. This value then is returned. The image can be rotated (not imporant for histogram):

** BMP/BME 280
(type ="bme280"= & ="bmp280"=)
You have to specify a protocol for accessing the sensor and the address (I2C) or CS-Pin (SPI) in your config file:
#+begin_src clojure :eval no
:sensors {:bme280
           {:type "bme280"
            :protocol "i2c"
            :address 0x76}
           :bmp280_0
           {:type "bmp280"
            :protocol "spi"
            :pin "18"}}
#+end_src

** TSL2591
(type ="tsl5281"=)
The TSL2591 sensor has no further options.

** DHT11
(type ="dht11"=)
You have to provide the pin of the sensor like this:
#+begin_src clojure :eval no
:sensors {:dht11
          {:type "dht11"
            :pin 26}}
#+end_src

** DS18B20
(type ="ds18b20"=)
The DS18B20 sensor has no further options:
#+begin_src clojure :eval no
:sensors {:DS18B20
           {:type "ds18b20"}}
#+end_src
