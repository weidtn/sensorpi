* Introduction
A program to read different sensor's data connected to for example a raspberry pi and send it to an influxdb. InfluxDB has to be already installed with a database. Install this on your own. (One way to easily install both grafana and influx is using the =install.sh= script found at https://github.com/Siytek/grafana-influx).

* Installation
It might be needed to install the dependencies for =opencv-python-headless= first:

#+begin_src shell eval no
sudo apt install libaom0 libatlas3-base libavcodec58 libavformat58 libavutil56 libbluray2 libcairo2 libchromaprint1 libcodec2-0.8.1 libcroco3 libdatrie1 libdrm2 libfontconfig1 libgdk-pixbuf2.0-0 libgfortran5 libgme0 libgraphite2-3 libgsm1 libharfbuzz0b libjbig0 libmp3lame0 libmpg123-0 libogg0 libopenjp2-7 libopenmpt0 libopus0 libpango-1.0-0 libpangocairo-1.0-0 libpangoft2-1.0-0 libpixman-1-0 librsvg2-2 libshine3 libsnappy1v5 libsoxr0 libspeex1 libssh-gcrypt-4 libswresample3 libswscale5 libthai0 libtheora0 libtiff5 libtwolame0 libva-drm2 libva-x11-2 libva2 libvdpau1 libvorbis0a libvorbisenc2 libvorbisfile3 libvpx5 libwavpack1 libwebp6 libwebpmux3 libx264-155 libx265-165 libxcb-render0 libxcb-shm0 libxfixes3 libxrender1 libxvidcore4 libzvbi0
#+end_src

Install via pip:
#+begin_src shell
pip install sensorpi
#+end_src

You can download the repo from github by running
#+begin_src shell :eval no
git clone https://github.com/weidtn/sensorpi.git
#+end_src

And then install with poetry:
#+begin_src shell
poetry install
#+end_src

* Configuration
All configuration is done in the config.edn file.
If you add a sensor here, it will automatically be read by the program and added to the measurement.
InfluxDB data also has to be set up in here it defaults to a local installation on the same raspberry pi without any authentication. To use a remote InfluxDB, change the URL in the config file.

The configuration is written in edn. This works similar to a python dictionary. Keywords and values are separated by whitespace.
You have to provide the keywords =:influxdb= and =:sensors= with your data. An example config.edn would look like this:
#+begin_src clojure :eval no
;; This is just an example config.edn file, you have to manually change the data.
{:influxdb {:url "http://localhost:8086"
            :db "test1"}

 :sensors {:cam  ;; name of the sensor
           {:type "camera" ;; type of the sensor. check supported types
            :rotate true} ;; some further possible options depending on sensor
           :ds18b20_1
           {:type "ds18b20"}
           :dht11_inside
           {:type "dht11"
            :pin 26}
           "TSL2591 upside down" ;; the sensor names can also just be strings
           {:type "tsl2591"}

           :bme280
           {:type "bme280"
            :address 0x76
            :protocol "i2c"}
           :bmp280_0
           {:type "bmp280"
            :protocol "spi"
            :pin "18"}
           :bmp280_1
           {:type "bmp280"
            :protocol "spi"
            :pin "12"}}}
#+end_src
* Usage:
Make sure to have an InfluxDB v1.8 running and all the sensors connected. Then write a config.edn file with the needed data.

This will use the config file in the measurement1 folder and save to db as measurement1 every 30 seconds. Measurement and interval are optional and the program will automatically ask for them in the commandline. If no config is given, it will search for a config.edn file in sensorpi's folder.
#+begin_src shell :eval no
sensorpi -m measurement1 -i 30 -c ./measurement1/config.edn
#+end_src

* Supported sensors
Currently the following sensors are supported. Their implementations can be found in the sensorpi/sensors folder. Feel free to add your own sensors!

- Camera (Integrating histogram)
- DHT11
- DS18B20
- TSL2591
- BMP280 (I2C, SPI)
- BME280 (I2C, SPI)

Multiple sensors should work if different addresses (I2C) or pins (SPI) are used.

** Camera
type "camera"

The camera can be used as a sensor. The camera can save an image to a path and integrate the picture's histogram. This integral value is then saved to the database if the keyword =:hist= is true. The image can be rotated by 180Â° (not imporant for histogram). Example camera config:

The folder where the image should be saved to needs to exist already.
#+begin_src clojure :eval no
:sensors {:cam
          {:type "camera"
           :rotate true
           :hist true                                ;; can also be false if you only need the image
           :save                                     ;; if the :save keyword does not exist, only a histogram is calculated
            {:path "/home/pi/measurement1/cam.png"   ;; saves image to the folder
             :timestamp true}}}                      ;; Adds a timestamp to the image before ".png"
#+end_src

A nice trick is to save the image to =/usr/share/grafana/public/img/= so you can access it from a grafana text panel and little html/js (or maybe just symlink it): https://gist.github.com/weidtn/d1171a896483899b606ec9663925147f

** BMP/BME 280
type "bme280" & "bmp280"

You have to specify a protocol for accessing the sensor and the address (I2C) or CS-Pin (SPI) in your config file:
#+begin_src clojure :eval no
:sensors {:bme280
           {:type "bme280"
            :protocol "i2c"
            :address 0x76}
           :bmp280_0
           {:type "bmp280"
            :protocol "spi"
            :pin "18"}}
#+end_src

** TSL2591
type "tsl5281"

The TSL2591 sensor has no further options.

** DHT11
type "dht11"

You have to provide the pin of the sensor like this:
#+begin_src clojure :eval no
:sensors {:dht11
          {:type "dht11"
            :pin 26}}
#+end_src

** DS18B20
type "ds18b20"

The DS18B20 sensor has no further options:
#+begin_src clojure :eval no
:sensors {:DS18B20
           {:type "ds18b20"}}
#+end_src
